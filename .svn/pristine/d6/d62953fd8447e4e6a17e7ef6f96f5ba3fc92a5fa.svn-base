package VisualServo;

import java.awt.Color;
import java.util.HashMap;

/**
 * BlobTracking performs image processing and tracking for the VisualServo
 * module.  BlobTracking filters raw pixels from an image and classifies blobs,
 * generating a higher-level vision image.
 *
 * @author previous TA's, prentice
 */
public class BlobTracking {
	protected int stepCounter = 0;
	protected double lastStepTime = 0.0;
	
	private double saturation_threshold = 0.95;

	public int width;
	public int height;


	// Variables used for velocity controller that are available to calling
	// process.  Visual results are valid only if targetDetected==true; motor
	// velocities should do something sane in this case.
	public boolean targetDetected = false; // set in blobPresent()
	public double centroidX = 0.0; // set in blobPresent()
	public double centroidY = 0.0; // set in blobPresent()
	public double targetArea = 0.0; // set in blobPresent()
	public double targetRange = 0.0; // set in blobFix()
	public double targetBearing = 0.0; // set in blobFix()

	/**
	 * <p>Create a BlobTracking object</p>
	 *
	 * @param width image width
	 * @param height image height
	 */
	public BlobTracking(int width, int height) {

		this.width = width;
		this.height = height;

	}





	/**
	 * <p>Computes frame rate of vision processing</p>
	 */
	private void stepTiming() {
		double currTime = System.currentTimeMillis();
		stepCounter++;
		// if it's been a second, compute frames-per-second
		if (currTime - lastStepTime > 1000.0) {
			//double fps = (double) stepCounter * 1000.0
			// / (currTime - lastStepTime);
			//System.err.println("FPS: " + fps);
			stepCounter = 0;
			lastStepTime = currTime;
		}
	}

	/**
	 * <p>Segment out a blob from the src image (if a good candidate exists).</p>
	 *
	 * <p><code>dest</code> is a packed RGB image for a java image drawing
	 * routine. If it's not null, the blob is highlighted.</p>
	 *
	 * @param src the source RGB image, not packed
	 * @param dest the destination RGB image, packed, may be null
	 */
	public void apply(Image src, Image dest) {

		stepTiming(); // monitors the frame rate

		// Begin Student Code
		System.out.println(src.getHeight() + " " + src.getWidth());
		System.out.println(blobPresent(src));
		int thresh = 0;
		int ch;
		while ((ch = System.in.read ()) != '\n')
			if (ch >= '0' && ch <= '9')
			{
				thresh *= 10;
				thresh += ch - '0';
			}
			else
				break;
		saturation_threshold = thresh / 100;
		Histogram.getHistogram(src, dest, true);
//		saturateBallPixels(src, dest);
		// End Student Code
	}
	
	private boolean blobPixel(int r, int g, int b) {
		float[] hsbvals = {0, 0, 0};
		Color.RGBtoHSB(r, g, b, hsbvals);
		float saturation = hsbvals[1];
		return saturation > this.saturation_threshold;
	}
		
	private byte[] getSaturatedColor(int r, int g, int b) {
		int[] rgb = {r, g, b};
		byte[] out = {0, 0, 0};
		for (int i=0; i < 3; i++) {
			out[i] = (byte) (rgb[i] > saturation_threshold ? 255 : 0);
		}
		return out;
 	}
	
	private static byte[] getGreyColor(int r, int g, int b) {
		int averageVal = (int) Math.round((r + g + b)/3.0);
		return new byte[] {(byte) averageVal, (byte) averageVal, (byte) averageVal};
	}
	
	
	private void saturateBallPixels(Image input, Image output) {
		for (int x=0; x < input.getWidth(); x++) {
			for (int y=0; y < input.getHeight(); y++) {
				byte[] newPixelVal;
				int pix = input.getPixel(x,y);
				int r = Image.pixelRed(pix);
				int g = Image.pixelGreen(pix);
				int b = Image.pixelGreen(pix);
				if (blobPixel(r,g,b)) {
					newPixelVal = getSaturatedColor(r, g, b);
				} else {
					newPixelVal = getGreyColor(r, g, b);
				}
				output.setPixel(x, y, newPixelVal[0], newPixelVal[1], newPixelVal[2]);
			}
		}
	}
	
	private static String getBallColor(int r, int g, int b) {
		float[] hsb = {0, 0, 0};
		Color.RGBtoHSB(r, g, b, hsb);
		float hue = hsb[0];
		if (hue > 0.75 || hue < 0.1) {
			return "red";
		} else if (hue < 0.2) {
			return "yellow";
		} else if (hue < 0.5) {
			return "green";
		} else {
			return "blue";
		}
	}
	
	private static boolean blobPresent(Image im) {
		HashMap<String, Integer> colorCounts = new HashMap<String, Integer>();
		for (int x=0; x < im.getWidth(); x++) {
			for (int y=0; y < im.getHeight(); y++) {
				int pix = im.getPixel(x,y);
				int r = Image.pixelRed(pix);
				int g = Image.pixelGreen(pix);
				int b = Image.pixelGreen(pix); 
				if (blobPixel(r,g,b)) {
					String ballColor = getBallColor(r, g, b);
					int pixelCount = colorCounts.containsKey(ballColor) ? colorCounts.get(ballColor) + 1 : 1;
					colorCounts.put(ballColor, pixelCount);
				}
			}
		}
		int blobPresentPixelCountThreshold = 1900;
		for (String color : colorCounts.keySet()) {
			if (colorCounts.get(color) > blobPresentPixelCountThreshold) {
				return true;
			}
		}
		return false;
	}
	
	
}
